#include <iostream>
using namespace std;

class Game {
public:
	void Init() {}
	void Draw(){}
	void Update()
	{

	}
	void Release() {}
};
void main()
{
	//2. 클래스
	// 객체 지향 프로그래밍
	// 그동안 콘솔에서 해온 프로그래밍 방식은 "절차 지향 프로그래밍" << 위에서 아래로 코드를 읽기만 하면 됨

	// 객체 지향 프로그래밍은
	// 객체를 여러개 만들어서
	//객체끼리 알아서 상호작용 되게 끔 만드는 게 객체 지향 프로그래밍 이다.
	// 쉽게 말해 class를 많이 쓰면 객체지향 프로그래밍.

	// 오늘 할 이론
	// 클래스 5대 원칙
	// 디자인 패턴

	Game* game = new Game();
	game->Init();
	while (true)
	{
		game->Draw();
		game->Update();
	}
	game->Release();

	// 객체 지향 프로그래밍이
	// 클래스로 덕지덕지 붙여져있는 건 알겠는데
	// 왜 쓰는 지?
	//
	// 절차 지향 프로그래밍 
	// 단점 ::
	//  - 기획 단계에서 뭔가 바뀌면, 수정하기 어려움. (이미 서로에게 너무 의존하고 있어서)
	//  (위에서 아래로 흐르고 있는데, 윗줄에서 수정이 일어나면, 아래를 모두 바꿔야함.)
	// - 유지보수성이 안 좋다
	// - 생산성도 안 좋다
	//	(협업을 하게 되면, 모두가 위에서 아래로 코드를 함)
	//  (파일 하나에서 위에서 아래로 짜게 되면)
	// A프로그래머가 5Line ~ 15Line 수정
	// B프로그래머가 30Line ~ 45Line 을 수정했는데
	// 이때 A프로그래머가 변수명을 수정했으면
	// Git murge할 때 문제가 많음.
	// 그래서 파일 분할을 최대한 많이 함.
	// 
	// 그래서 객체지향 프로그래밍을 하게 됨.
	// 
	// 객체 지향 프로그램이
	// 장점 :: 
	// - 유지보수성이 좋다
	// - 협업에 좋다
	// 
	// 단점 ::
	// - 이론상 없지만, 코드 레벨이 조금 높음. 
	// - 실행속도가 느리다 (하지만 코드를 최적화 하는 것보단, 3d모델이나 2d 텍스쳐를 최적화 하는 것이 나음)
}