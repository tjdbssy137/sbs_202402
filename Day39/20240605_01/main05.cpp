#include <iostream>
using namespace std;

void main()
{
	// 길찾기 알고리즘
	// 다익스트라보다 더 좋은 게 없는 거 같은데?
	// BFS 만큼 깔끔하게 길 찾는 방법이 없을 줄 알았는데(간선의 비용이 다른 경우 문제가 생김)
	// 간선에 비용을 추가해서 더 효율적인 길을 찾는 Dijikstra 로직이 만들어짐.
	// (원하는 건 end 포인트에 대한 길찾기인데 뭔가 효율적이지 않음)

	// dijikstra를 조금 변형해서
	// astar 알고리즘
	// 비용계산을 조금 다르게 함
	// queu에 넣을 떄
	// 다익스트라 같은 경우 -> G [내 현재까지 온 비용 + 거기까지 가는 비용]
	// astar 경우 -> G [내 현재까지 온 비용 + 거기까지 가는 비용] + H (지금 좌표부터 해당 내용까지 가는 예상 기댓값)

	// 우선 순위 큐에 대해 알아야하고
	// DFS, BFS에 대해 알아야하고
	// BFS -> 다익스트라로 변형하는 과정
	// 다익스트라 -> 에이스타로 변형하는 과정

	// 길찾기 알고리즘
	// 가장 보편화되어있는 알고리즘
	// DFS, BFS
	// -> 그래프 자료구조
	//		(정점, 간선)
	// A정점에서 D정점을 갈 수 있는지?

	// DFS, BFS 차이점
	// DFS -> 깊이 탐색 알고리즘으로, 
	//		stack을 통해서 하나의 정점을 선택헀으면, 
	//		그 정점에서 더이상 갈 수 없는 지점까지 먼저 탐색

	// BFS -> 넓이 탐색 알고르즘으로, queue를 통헤서
	//		갈수 있는 정점들을 depth가 같아지는 선에서 점점 넓혀감
	//		'최대한 빨리' 알고리즘

	// DFS, BFS -> 그래서 특정 정점에서 @정점을 갈 수 있냐 없냐.는 문제가 발생
	// 그럼 A->D 노드를 가는데, 사실은 
	// A -> C -> D 가는 게 제일 빠른데
	// A -> E -> B -> D 이렇게 간다고 길을 알려줄지도.
	// 왜냐면 DFS, BFS는 비용은 체크 안하고 단순하게 갈 수 있냐 없냐만 체크하기 때문.

	// Dijikstra 알고리즘
	// 간선에 비용을 추가 시켜서, BFS 로직을 적용.
	// '최대한 빨리' 각 정점을 지나는 방법을 탐색하는 알고리즘
	// BFS (queue -> priority_queue로 수정)

	// 또 문제가 발생
	// 단순히 직선방향으로만 탐색해도 금방 찾을 것 같은 목적지인데
	// 모든 경우의 수를 계산하려 함.
	// -> 느려짐

	// A* 알고리즘 -> 목적지가 있는 경우에 최적의 길찾기를 계산
	// queue -> priority_queue
	// priority_queue 넣는 비용을
	// 다익스트라 -> 처음 위치에서 해당 위치로 가는데 드는 비용 (G)
	// 에이스타 -> 처음 위치에서 해당 위치로 가는데 드는 비용 (G)
	//						+ 해당위치에서 목적지까지 가는데 드는 예상 비용 (H)




	// 자료구조, 알고리즘 (코테, 면접)
	// 자료구조
	// - Linked List, Vector, BinaryTree
	// - map
	// - Queue, Stack
	// - Priority Queue
	
	// 알고리즘
	// - BinarySearch
	// - DFS, BFS
	// - Dijistra
	// - A*
}

// 숙제 2개 

// 1. 콘솔에서 Astar로 미로 길 찾기(BFS랑 길이 달라지진 않음)
// 2. Window API에서 BFS나 Astar 사용해서 타일 클릭하면 플레이어가 해당 타일로 이동하는 로직 만들기