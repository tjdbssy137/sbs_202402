#include <iostream>
using namespace std;


void main()
{
	// 저번시간까지 배운것
	//  - 우선순위큐

	// ==> 가장 우선도가 높은 노드를 먼저꺼내게하는 자료구조
	// 우선순위큐 : 알고리즘에 쓰입니다.
	//  - 데이터를 넣을때 시간복잡도 : O(logN)
	//  - 데이터를 뺄때 시간복잡도 : O(logN)
	//  - 다음 데이터가 무엇인지 확인하는데 드는 시간복잡도 : O(1)


	// 콘솔로 넘어온 이유 : 
	//   길찾기 알고리즘을 만들기위해서 콘솔에서 그 기반을 다지기 위함.


	// 그래프 자료구조
	// 
	// 그래프란??
	//   - 정점과 간선으로 이루어진 자료구조
	//   - Vertex, Edge로 이루어진 자료구조


	// 코딩테스트
	//  적게나오면 3문제, 많이나오면 5문제

	// 1번 문제 : 문자열 자르기 / 문자열 조합하기 / 문자열로 가지고노는
	//		  아니면 완전 기초적인 문제

	// 2번 문제 : 그리디 알고리즘, 
	//	(알고리즘 이름을 몰라도 대충 
	//		 프로그래밍 기본기만 있으면 풀수있는 알고리즘)

	// 3번 문제 : 그래프 자료구조를 사용한 알고리즘 
	// 4번 문제 : 그래프 자료구조를 사용한 알고리즘 or 수열 문제
	// 5번 문제 : 수열 문제 (Dynamic programming)


	// 그래프란??
	//   - 정점과 간선으로 이루어진 자료구조
	//   - Vertex, Edge로 이루어진 자료구조

	//   - 길찾기 알고리즘에 많이 사용됩니다.


	// 그래프 자료구조를 사용한 알고리즘
	// DFS, BFS

	// 길찾기 알고리즘
	// DFS, BFS
	//  - 아, 길찾기 알고리즘

	// 길찾기 알고리즘.
	//  


	// DFS, BFS
	// 실제 프로그래머스의 문제 통해서 수업진행하겠습니다.


}


void Comment2()
{
	// 코딩테스트 문제 보는법
	// 그림은 -> 1번예제는 샘플로 왜 이렇게 돼서, 결과값이 뭐가 나와야한다.
	// 

	// 파악해야할 내용.
	// 코테에서 파악해야할 내용 : 
	//   - 1. 입력값이 뭐가 들어오는건지?
	//   - 2. 그래서 어떤걸 반환시키면 되는지?

	// 컴퓨터의 개수 n, 
	// 연결에 대한 정보가 담긴 2차원 배열 computers
	// 
	// return : 네트워크의 개수
	// 
	// 문제를 이해하는데 10분

	// DFS, BFS 
	// 그림이 뭔가 길찾기스럽다 << 이러면 DFS, BFS 일확률이 90프로가 넘습니다.

	// 수학문제도 그렇지만
	// 풀이방식이 1개는 아닙니다.

	// DFS, BFS 둘다 풀수있다.
	// 
	// BFS 단점
	//  - 메모리 낭비 (메모리가 부족할수있다.) (극단적인 상황)

	// DFS 단점
	//  - 최소값이랑은 거리가 멀다.


	// 문제에서 [최소] [최대한 빨리] 이런 단어가 나오는 길찾기 문제
	//   ==> BFS를 써라

}