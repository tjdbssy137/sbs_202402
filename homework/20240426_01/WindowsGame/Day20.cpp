void Summary()
{
	// 1. CenterRect, Vector 이해
	// 2. 충돌처리
}

void Comment1()
{
	// 1. CenterRect
	// 2D게임을 제작하다보면 충돌체크를 할 일이 되게 많다.
	// 충돌체크란, A오브젝트와 B오브젝트가 부딪혔는지 체크하는 것.
	//	-> e.g. 슈퍼마리오에서 마리오가 버섯과 충돌 됐는지, 몬스터와 충돌 됐는지..
	//		-> 버섯일시, 마리오가 커짐
	//		-> 몬스터일시, 죽음
	// 게임컨텐츠 로직에서 70%는 충돌로직임. 그만큼 중요!
	// 이번에 숙제한 것도
	// 대부분이 충돌체크로 일어나는 게임,,
	 

	// 2D 게임에서는 충돌 패턴이 3가지.
	// 점, 사각형, 원
	// pt, Rect, Circle
	
	// PtInRect
	// RectInRect
	// PtInCircle
	// RectInCircle
	// CircleInCircle
	// == (PtInPt) // 얘는 없는거나 마찬가지라 사실상 5가지임.
}

void Comment2()
{
	// <Vector>

	// Vector란 무엇이냐..
	// C++에서의 자료구조와 다른 것.
	// 기하와 벡터의 벡터..

	// Vector는 점이나 방향정보를 가르키는 변수.
	// (x, y) 3D에서는 (x, y, z)
	
	// x, y라는 변수
	// 위치정보, 방향정보 두 가지를 알 수 있음.
	// positionX, positionY
	// directionX, directionY
	
	// x, y라는 변수를 가지고 있기에 (위치, 방향) 정보를 가르키는 변수가 된 것.
	
	// 2D에선 내적을 주로 배움.
	// WHY -> 외적은 보통 회전할 때 다룸.(3D)
	// 외적도 쓰긴 함.
	// 무엇보다도, 2D에서는 외적이 없음.
	// 외적은 두 Vector사이의 수직Vector를 구할 때 사용. (모두 방향 벡터 의미)
	// ( 2D에서는 Z가 없으니까 없음.)
	
	
	// 내적은
	// 어떤 수학자가 공교롭게도 수식을 하나 발견,,
	// A라는 벡터와 B라는 벡터가 있을 때
	// A.x * B.x + A.y * B.y = |A| * |B| * cos(theta) A와 B사이의 각도
	// 라는 공식을 발견
	
	// Vector 2개를 가지고 있으면 (x, y의 값을 갖고 있다)
	// 벡터 내적의 값 / |A| * |B| = cos(theta)
	// 그러면 A와 B 사이의 각도를 구할 수 있다.
	// 
	// 프로그램이기에 cos없애는 거? 일도 아님. (함수 하나면 됨)
	// acos(벡터내적값/|A| * |B|) = 각도 값.
	
	// **즉, 내적은 각도를 구하기 위해 쓴다.**
	// 0~180도가 나오게 됨.(설명은 PPT 참고)
	
	// 게임수학은 어차피 외우는 것
	// 수학을 잘하는 사람이나
	// 못하는 사람이다
	// 결국은 더 빨리 외운 사람이 더 빨리 코드치고 더 잘 사용.
	// 외워야 생각 남.

	// 내적 = 각도
	// 외적 = 방향 (왼쪽에 있는지, 오른쪽에 있는지 판별할 때)
	// 
}

void Homework()
{
	// 벽돌깨기..
	// 수요일날 하루 종일 벽돌깨기 풀이
	// 꼭... 해오기
	// 벽돌이 위에서 아래로 내려오는 것까지는 구현 안해도 됨.
	// 네모공 
	
	// 반사 벡터
	// 벡터가 방향 벡터라고 가정했을 때.
	// 벽에 부딪히면 꺾여야 함.
	
	// 벡터의 반사
	/*
	Original Vector
			^
			|
			/
		   /
		  /
		 /
		 + ---------> Normal Vector
		 \
		  \
		   \
		    \
			|
			Reflected Vector
	*/
}

void Comment3()
{
	// CenterRect
	// 점, Rect, Circle
	
	// RECT => 사용하기 불편하게 되어있는 변수
	// 1. 이동하려면 모든 변수를 수정해주어야 한다.
	// 2. 이돌 할 때, 소수점 단위로는 이동할 수 없다.
	//	(소수점이 계속 합쳐지면 정수 단위로 넘어갈 수 없다.)
	
	// 단점을 보완하여 만든 사용하기 편한 사각형 변수 --> CenterRect

	// !! CenterRect의 특징
	// 중심점을 Position으로 잡고 있다.
	// Width와 Height를 갖고 있음.(중심점을 기준으로 한)

	// 그러면 앞으로 이동할 때, left right top bottom처럼 모두 변경 시키는 것이 아니라
	// 중심점 (position)만 이동 시키면 전체가 이동한 것 같은 효과를 볼 수 있다.

	// ToRect는 Rect로 만들어진 함수들이 기존에 있어서 사용하는 함수
	// 현재 CenterRect 기준으로 RECT 자료형에 새롭게 만든다.
	
	// 프로그래밍에서
	// TO~
	// FROM~
	// 이런걸 Convert라고 하는 데
	// A자료형에서 B자료형으로 옮길 때 사용.


}

void Comment4()
{
	// inline 키워드는 #define (매크로 한 것과 같은 속도를 내기 위해서 사용)
	// 근데 CPU 마음이라 inline을 쓴다고 해서 빠르게 해줄지 말지는 CPU가 알아서 결정함.
	// 쓴다고 손해는 없음.
	// inline의 단점 : 헤더에서만 구현해야함. == 링크 에러가 발생할 확률이 있음.
}